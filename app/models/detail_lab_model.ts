export interface Detail {
  id: number
  title: string
  header: string
  body: string
  code: string
}

export const detailLab: Detail[] = [
  {
    id: 15,
    title: 'Lab',
    header: 'Routes',
    body: `
    โค้ดนี้แสดงการตั้งค่าของเส้นทาง (routes) สำหรับการจัดการโพสต์ในแอปพลิเคชันโดยใช้ AdonisJS ซึ่งเป็นเว็บเฟรมเวิร์กที่ใช้ JavaScript/TypeScript ร่วมกับ Node.js. เป้าหมายของโค้ดนี้คือการตั้งเส้นทางต่างๆ ที่เกี่ยวข้องกับการสร้าง, ดู, แก้ไข, และลบโพสต์ ซึ่งจะเชื่อมโยงไปยังเมธอดต่างๆ ใน PostsController ที่ทำหน้าที่ควบคุมและจัดการข้อมูลโพสต์ในระบบ.

    การตั้งค่าเส้นทางเริ่มต้นกำหนดให้เส้นทางหลัก ('/') ที่ผู้ใช้เข้าถึง จะทำการเปลี่ยนเส้นทางไปยังหน้าโพสต์หลักผ่านคำสั่ง response.redirect().toRoute('posts.home'). ซึ่งจะทำให้ผู้ใช้ถูกนำไปยังหน้าแรกของการแสดงโพสต์. เส้นทางต่อมาคือการตั้งเส้นทางสำหรับการแสดงรายการโพสต์ทั้งหมดที่ใช้ GET method และจะเชื่อมโยงไปยังเมธอด index ใน PostsController ซึ่งรับผิดชอบในการแสดงโพสต์ทั้งหมดในระบบ.

    เส้นทางต่อไปนี้กำหนดให้สามารถสร้างโพสต์ใหม่ได้ผ่าน POST method ที่ /posts, และจะเรียกใช้เมธอด store เพื่อบันทึกโพสต์ใหม่ลงในระบบ. นอกจากนี้ยังมีเส้นทางสำหรับการแสดงฟอร์มสร้างโพสต์ใหม่ (/posts/create) ที่จะเรียกเมธอด create เพื่อแสดงฟอร์มที่ผู้ใช้สามารถกรอกข้อมูลโพสต์ใหม่.

    การดูรายละเอียดโพสต์จะใช้เส้นทางที่มีพารามิเตอร์ id เพื่อระบุโพสต์ที่ต้องการดู ซึ่งจะเชื่อมโยงไปยังเมธอด show ที่แสดงรายละเอียดของโพสต์นั้นๆ. หากต้องการแก้ไขโพสต์, ผู้ใช้สามารถเข้าถึงฟอร์มแก้ไขโพสต์ที่ /posts/:id/edit โดยเมธอด edit จะถูกเรียกเพื่อแสดงฟอร์มที่ผู้ใช้สามารถแก้ไขข้อมูลโพสต์ได้.

    เส้นทางสำหรับการอัพเดตโพสต์จะใช้ POST method ที่ /posts/:id/update, ซึ่งจะทำการอัพเดตโพสต์ที่มี id ตรงตามที่ระบุใน URL, และสุดท้ายเส้นทางที่ใช้สำหรับการลบโพสต์นั้นๆ คือ /posts/:id/delete โดยเมธอด destroy จะลบโพสต์ที่มี id ตามที่กำหนด.

    การใช้คำสั่ง .as() ในการตั้งชื่อเส้นทางนี้ทำให้การอ้างอิงเส้นทางในแอปพลิเคชันสะดวกและง่ายขึ้น, โดยไม่จำเป็นต้องใช้ URL เต็มๆ. เมื่อใช้ชื่อเส้นทางแล้ว, ถ้ามีการเปลี่ยนแปลงเส้นทางในอนาคต เราก็สามารถอัพเดตได้ง่ายโดยไม่ต้องแก้ไขที่หลายๆ จุดในโค้ด, ซึ่งทำให้การบำรุงรักษาแอปพลิเคชันทำได้ง่ายและยืดหยุ่นขึ้น.`,
    code: `
      import type { HttpContext } from '@adonisjs/core/http'
      import router from '@adonisjs/core/services/router'
      import PostsController from '#controllers/posts_controller'

      router.get('/',({response}:HttpContext)=>{
          response.redirect().toRoute('posts.home')
      })

      router.get('/posts',[PostsController,'index']).as('posts.home')
      router.post('/posts',[PostsController,'store']).as('posts.store')
      router.get('/posts/create',[PostsController,'create']).as('posts.create')
      router.get('/posts/:id',[PostsController,'show']).as('posts.show')
      router.get('/posts/:id/edit',[PostsController,'edit']).as('posts.edit')
      router.post('/posts/:id/update',[PostsController,'update']).as('posts.update')
      router.get('/posts/:id/delete',[PostsController,'destroy']).as('posts.delete')`,
  },
  {
    id: 16,
    title: '',
    header: 'Master',
    body: `
    โค้ดนี้เป็นแม่แบบ (template) HTML ที่ใช้ใน AdonisJS ซึ่งมีการใช้โครงสร้างพื้นฐานของ HTML เพื่อสร้างหน้าเว็บที่สามารถแสดงเนื้อหาต่างๆ ของแอปพลิเคชัน. การออกแบบแม่แบบนี้ช่วยให้การสร้างหน้าเว็บมีความยืดหยุ่นและสามารถใช้งานซ้ำได้, โดยการใช้ AdonisJS's layout system ที่รองรับการใช้โครงสร้างพื้นฐานนี้ร่วมกับการแสดงผลเนื้อหาจากการ render ในส่วนต่างๆ.

    ในส่วนของ <head>, โค้ดนี้กำหนดให้มีการเชื่อมโยงไปยังไฟล์ CSS จาก Semantic UI (/semantic/semantic.min.css) ซึ่งเป็นไลบรารีที่ช่วยในการสร้าง UI ที่ดูดีและตอบสนอง (responsive). นอกจากนี้ยังมีการใช้ jQuery และ Semantic UI's JavaScript (/semantic/semantic.min.js) เพื่อเสริมการทำงานของหน้าเว็บให้มีความสามารถในการตอบสนองกับผู้ใช้ เช่น การใช้งาน Accordion, Modal, หรือฟีเจอร์อื่นๆ ที่รองรับใน Semantic UI.

    ใน <body>, เริ่มจากการเรียกใช้ @include('partials/navbar') ซึ่งเป็นการนำส่วนของเมนูนำทาง (navbar) ที่ถูกจัดเก็บในไฟล์ navbar มารวมในแม่แบบนี้, ทำให้ไม่ต้องซ้ำโค้ดเมนูนำทางในแต่ละหน้า. หลังจากนั้น, โค้ดจะมีการใช้ <div class="ui container"> เพื่อกำหนดพื้นที่ที่จะแสดงเนื้อหาหลักของหน้าเว็บ โดยส่วนนี้จะได้รับการเติมเต็มด้วย {{{await $slots.main()}}}, ซึ่งเป็นการนำเนื้อหาหลักจากส่วนที่ถูกเรียกใช้ในแต่ละหน้า (slot) มารวมในแม่แบบนี้.

    สุดท้าย, หากมีการกำหนดสคริปต์พิเศษสำหรับแต่ละหน้า, โค้ดนี้จะตรวจสอบว่ามีการตั้งค่า @if($slots.script) หรือไม่, และหากมีการกำหนดสคริปต์, จะทำการแทรกสคริปต์นั้นๆ ลงในหน้าเว็บโดยใช้ {{{await $slots.script()}}}. การทำงานนี้ช่วยให้สามารถแทรกโค้ด JavaScript เฉพาะที่เกี่ยวข้องกับฟังก์ชันการทำงานของหน้าแต่ละหน้าผ่านการใช้ slot ได้อย่างสะดวก.

    โครงสร้างนี้ทำให้การจัดการ layout ของแอปพลิเคชันเป็นไปอย่างมีระเบียบ, ยืดหยุ่น, และง่ายต่อการบำรุงรักษา, เพราะสามารถกำหนดโครงสร้างพื้นฐานไว้ในไฟล์เดียวแล้วใช้ร่วมกันในหลายๆ หน้า.`,
    code: `
      <!DOCTYPE html>
      <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>{{ title }}</title>
            <link rel="stylesheet" type="text/css" href="/semantic/semantic.min.css">
            <script
                src="https://code.jquery.com/jquery-3.1.1.min.js"
                integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
                crossorigin="anonymous">
            </script>
            <script src="/semantic/semantic.min.js"></script>
        </head>
        <body>
            @include('partials/navbar')
            <div class="ui container">
                {{{await $slots.main()}}}
            </div>

            @if($slots.script)
                {{{await $slots.script()}}}
            @end
        </body>
      </html>`,
  },
  {
    id: 17,
    title: '',
    header: 'Navbar',
    body: `
    โค้ดนี้เป็นส่วนของเมนูนำทาง (Navbar) ที่ใช้ในแอปพลิเคชัน ซึ่งสร้างขึ้นโดยใช้ Semantic UI, ซึ่งเป็นไลบรารีที่ช่วยให้การออกแบบ UI เป็นไปอย่างรวดเร็วและสวยงาม. ในที่นี้, เมนูจะมีพื้นหลังสีเทา (ใช้คลาส ui grey large menu inverted) และมีการใช้ inverted เพื่อเปลี่ยนสีของข้อความและพื้นหลังให้เป็นไปในทิศทางที่ตรงกันข้าม, ซึ่งทำให้เมนูดูเด่นขึ้นเมื่ออยู่บนพื้นหลังมืด.

    ในเมนูนี้, มีการใช้ <div class="header item"> เพื่อสร้างส่วนที่เป็นชื่อของเมนู, โดยในที่นี้มีการตั้งชื่อเมนูเป็น "Blog". นอกจากนี้, ยังมีการใช้ลิงก์ (<a href="{{ route('posts.home') }}">) ซึ่งเมื่อคลิกจะพาผู้ใช้ไปยังหน้าแรกของระบบบล็อก, โดยการใช้ route('posts.home') ซึ่งจะทำการสร้าง URL ที่ชี้ไปยังเส้นทางที่ชื่อว่า posts.home, ซึ่งถูกกำหนดในไฟล์เส้นทาง (routes) ของแอปพลิเคชัน.

    การออกแบบนี้ช่วยให้การสร้างเมนูนำทางเป็นไปอย่างสะดวกและดูดี, โดยสามารถนำไปใช้ในหลายหน้าเว็บได้โดยไม่ต้องเขียนโค้ดซ้ำ.`,
    code: `
      <div class="ui grey large menu inverted">
        <div class="header item">
            <a href="{{ route('posts.home') }}">Blog</a>
        </div>
      </div>`,
  },
  {
    id: 18,
    title: '',
    header: 'Alert',
    body: `
    โค้ดนี้เป็นการสร้าง Modal หรือ กล่องข้อความแจ้งเตือน (Alert) ด้วยการใช้ Semantic UI, ซึ่งเป็นไลบรารี CSS ที่ช่วยในการออกแบบ UI ที่ดูดีและสะดวก. การสร้าง Modal นี้จะมีขนาดเล็ก โดยใช้คลาส ui tiny modal และมันจะมีการแสดงกล่องข้อความที่ใช้สำหรับแจ้งเตือนผู้ใช้หรือยืนยันการกระทำใดๆ โดยที่สามารถกำหนดเนื้อหาภายในได้ยืดหยุ่น. ในส่วนของโค้ดที่แสดง, Modal นี้แบ่งออกเป็นสามส่วนหลักที่ทำงานร่วมกัน:

    ส่วนแรกคือ Header ซึ่งใช้สำหรับแสดงหัวข้อหรือชื่อของข้อความที่ต้องการแจ้งเตือน. โดยในที่นี้จะใช้ตัวแปร title ในการแสดงข้อความที่ถูกส่งมาให้ในตำแหน่งนี้. เมื่อมีการส่งค่า title ผ่านทาง slot, ส่วนนี้จะทำการแสดงข้อมูลนั้นในหัวข้อของ Modal.

    ส่วนที่สองคือ Content ซึ่งเป็นส่วนที่แสดงเนื้อหาหรือข้อมูลที่ต้องการแจ้งเตือนใน Modal. การใช้ @if($slots.main) จะทำการตรวจสอบว่ามีการส่งข้อมูลมาที่ main slot หรือไม่. ถ้ามีการส่งข้อมูลมา, ข้อมูลนั้นจะถูกแสดงในส่วนนี้, ทำให้การใช้งาน Modal นี้สามารถปรับแต่งได้ตามเนื้อหาที่ต้องการแสดง.

    สุดท้ายคือ Actions ซึ่งเป็นส่วนที่มีปุ่มหรือลิงก์ต่างๆ ที่ผู้ใช้สามารถคลิกเพื่อทำการกระทำบางอย่าง เช่น การยืนยันหรือการยกเลิก. เช่นเดียวกับในส่วนของ content, ระบบจะตรวจสอบว่าได้มีการส่งข้อมูลที่เกี่ยวกับ actions หรือไม่ผ่านทาง @if($slots.actions). หากมีข้อมูลเกี่ยวกับ actions มาใน slot นี้, ระบบจะทำการแสดงปุ่มเหล่านั้นในส่วนของ actions.

    การใช้ slots ในลักษณะนี้ช่วยให้โค้ดในส่วนของ Modal มีความยืดหยุ่นและสามารถนำกลับมาใช้ใหม่ได้ในหลายๆ สถานการณ์โดยไม่ต้องกำหนดเนื้อหาทั้งหมดภายในโค้ดหลัก.`,
    code: `
      <div class="ui tiny modal">
        <div class="header">
            {{ title }}
        </div>
        <div class="content">
            @if($slots.main)
                {{{await $slots.main()}}}
            @end
        </div>
        <div class="actions">
            @if($slots.actions)
                {{{await $slots.actions()}}}
            @end
        </div>
      </div>`,
  },
  {
    id: 19,
    title: '',
    header: 'Button',
    body: `
    โค้ดนี้ใช้สร้างปุ่มโดยใช้คลาสจาก Semantic UI ซึ่งเป็นไลบรารี CSS ที่ช่วยให้การออกแบบเว็บแอปพลิเคชันดูดีและใช้งานง่าย. ในโค้ดนี้, <a> แท็กถูกใช้ในการสร้างลิงก์ที่ทำหน้าที่เป็นปุ่ม. คลาส ui button จะทำให้ลิงก์นี้กลายเป็นปุ่มที่มีลักษณะตามการตั้งค่าของ Semantic UI.

    ภายในปุ่มนี้, เราสามารถใช้ตัวแปรต่างๆ เพื่อทำให้มันมีลักษณะเฉพาะและตอบสนองต่อความต้องการของผู้ใช้งาน. ตัวแปร {{ name }} จะทำให้สามารถกำหนดชื่อหรือคลาสเพิ่มเติมให้กับปุ่มได้, ซึ่งสามารถใช้เพื่อปรับแต่งลักษณะของปุ่มให้ตรงตามความต้องการ. ตัวแปร {{ action }} จะกำหนดเส้นทางหรือ URL ที่ปุ่มจะพาผู้ใช้ไปเมื่อคลิก, ซึ่งทำให้สามารถนำไปใช้งานในสถานการณ์ต่างๆ ได้ง่าย.

    นอกจากนี้, ตัวแปร {{ label }} จะทำหน้าที่เป็นข้อความที่แสดงบนปุ่ม, ซึ่งสามารถตั้งค่าตามข้อความที่ต้องการให้ปรากฏบนปุ่มได้. ด้วยการใช้รูปแบบนี้, โค้ดนี้ช่วยให้การสร้างปุ่มในเว็บแอปพลิเคชันง่ายและยืดหยุ่น, เนื่องจากสามารถปรับแต่งได้ตามตัวแปรที่ส่งมาในแต่ละสถานการณ์.`,
    code: `
      <a class="ui button {{ name }}" href="{{ action }}">{{ label }}</a>`,
  },
  {
    id: 20,
    title: '',
    header: 'Input',
    body: `
    โค้ดนี้ใช้สร้างฟอร์มอินพุตโดยการใช้ Semantic UI ซึ่งช่วยให้การจัดการฟอร์มดูสะอาดและใช้งานง่ายขึ้น. ฟอร์มอินพุตนี้จะมีการปรับแต่งตามชนิดของอินพุต (input) และตัวแปรที่ส่งมาผ่านตัวแปรต่างๆ เช่น label, type, name, size, value, และ placeholder.

    เริ่มจากส่วนแรก, โค้ดจะตรวจสอบว่า label มีค่าอยู่หรือไม่. ถ้ามีค่า, มันจะสร้าง <label> โดยใช้ชื่อ name เป็น for attribute และแสดงข้อความ label ที่ส่งมาให้. ถ้าไม่มี, จะไม่สร้าง <label> ขึ้นมา.

    ส่วนถัดไปคือการสร้าง <input> ซึ่งจะมีลักษณะแตกต่างกันขึ้นอยู่กับค่า type. หาก type เป็น "submit", ระบบจะสร้างปุ่มอินพุตที่มีคลาส ui button ซึ่งจะทำให้มันดูเหมือนปุ่มจาก Semantic UI. หาก type ไม่ใช่ "submit", จะสร้าง <input> ปกติที่รองรับประเภทต่างๆ เช่น text, number, หรือ email และใช้ค่า name, size, value, placeholder, และ required ตามลำดับ.

    สุดท้าย, ฟังก์ชัน $props.except(['label']).toAttrs() จะนำค่าของตัวแปรที่ไม่ได้เป็น label มาแปลงเป็น attributes สำหรับ <input>, เพื่อให้สามารถใช้งานได้อย่างยืดหยุ่นและไม่ซ้ำซ้อนกับ label.

    การใช้โค้ดนี้ทำให้สามารถสร้างฟอร์มอินพุตที่มีการปรับแต่งได้ตามประเภทของข้อมูลที่ต้องการเก็บ โดยสามารถเพิ่มการตรวจสอบค่าหรือการกำหนด placeholder เพื่อให้ประสบการณ์การใช้งานของผู้ใช้ดีขึ้น.`,
    code: `
      <div class="field">
        @if(label)
            <label for="{{ name }}">{{ label }}</label>
        @end
        @if(type=="submit")
            <input id="{{ name }}" class="ui button" {{ $props.except(['label']).toAttrs() }}>
        @else
            <input id="{{ name }}" type="{{ type }}" name="{{ name }}" size="{{ size }}" value="{{ value }}" {{ $props.except(['label']).toAttrs() }} placeholder="{{ placeholder }}" required>
        @end
      </div>`,
  },
  {
    id: 21,
    title: '',
    header: 'Textarea',
    body: `
    โค้ดนี้เป็นการสร้างฟอร์มช่องกรอกข้อความประเภท textarea ที่ใช้สำหรับการกรอกข้อมูลยาวๆ เช่น ข้อความความคิดเห็น หรือเนื้อหาในฟิลด์ที่ต้องการพื้นที่มากขึ้นในการกรอกข้อมูล โดยจะใช้ Semantic UI เพื่อจัดการรูปแบบของฟอร์มให้ดูเรียบร้อยและใช้งานง่าย.

    ในส่วนแรกของโค้ดจะมี <label> ที่กำหนดข้อความที่แสดงให้ผู้ใช้เห็น เพื่ออธิบายว่าผู้ใช้ควรกรอกอะไรในช่องข้อความนี้ โดยใช้ค่า name เป็นค่าใน for attribute ซึ่งจะเชื่อมโยงกับ <textarea> ที่จะถูกแสดงภายใต้ข้อความนี้. เมื่อผู้ใช้เห็นข้อความนี้จะรู้ทันทีว่าควรกรอกข้อมูลอะไรในช่องนั้นๆ.

    ต่อมาจะเป็น <textarea> ที่เป็นช่องกรอกข้อมูลจริง ซึ่งมีคุณสมบัติต่างๆ ที่ช่วยให้การกรอกข้อมูลเป็นไปอย่างสะดวก. ในโค้ดนี้มีการกำหนด name, rows, cols, placeholder, และ required. ค่า name จะช่วยให้การส่งข้อมูลไปยังเซิร์ฟเวอร์เป็นไปได้โดยที่เซิร์ฟเวอร์รู้ว่าข้อมูลนี้มาจากฟิลด์ไหน. ค่า rows และ cols ถูกใช้เพื่อกำหนดขนาดของช่องกรอกข้อความทั้งในด้านความสูงและความกว้าง. ส่วน placeholder จะช่วยแสดงข้อความตัวอย่างที่บ่งบอกให้ผู้ใช้รู้ว่าเขาควรกรอกข้อมูลประเภทไหนในฟิลด์นั้น. และที่สำคัญคือ required ที่ทำให้ฟิลด์นี้ต้องมีการกรอกข้อมูลก่อนที่ผู้ใช้จะส่งฟอร์มได้.

    สุดท้าย value ใช้เพื่อกำหนดค่าที่จะแสดงอยู่ในช่องกรอกข้อความ หากมีการส่งค่ามาแล้ว, ช่องกรอกข้อความนี้จะแสดงค่าเหล่านั้นเพื่อให้ผู้ใช้เห็นข้อมูลที่กรอกไปก่อนหน้านี้. นอกจากนี้ยังสามารถใช้โค้ดนี้ในกรณีที่ต้องการให้ข้อมูลในฟอร์มมีความยืดหยุ่นและรองรับการกรอกข้อความที่ยาวขึ้นได้อย่างมีประสิทธิภาพ.`,
    code: `
      <div class="field">
        <label for="{{ name }}">{{ label }}</label>
        <textarea name="{{ name }}" rows="{{ rows }}" cols="{{ cols }}" placeholder="{{ placeholder }}" required>{{ value }}</textarea>
      </div>`,
  },
  {
    id: 22,
    title: '',
    header: 'Posts',
    body: `
    โค้ดนี้เป็นตัวอย่างของการสร้างหน้าเว็บที่แสดงรายการ Posts โดยใช้ AdonisJS ร่วมกับ Semantic UI ในการตกแต่งและจัดการฟอร์มต่างๆ. เริ่มต้นจากการใช้ @layouts.master ซึ่งเป็นการใช้งาน layout หลักสำหรับหน้าเว็บนั้นๆ ซึ่งจะมีการตั้งชื่อของหน้าให้เป็น "Posts" ผ่านการกำหนดค่าพารามิเตอร์ title.

    ภายในเนื้อหาของหน้านี้ จะมีการแสดงหัวข้อใหญ่ <h1> ที่ใช้คลาส ui header จาก Semantic UI เพื่อให้หัวข้อมีขนาดใหญ่และดูเด่น.

    ถัดมา เป็นการแสดงรายชื่อ Posts ในรูปแบบของลิสต์ที่มีเครื่องหมายหัวข้อ (bullet points) โดยใช้ @each เพื่อทำการวนลูปแสดงข้อมูลจากตัวแปร posts. ภายในลูปจะสร้าง <li> ซึ่งภายในจะมีลิงก์ <a> ที่เชื่อมไปยังรายละเอียดของโพสต์แต่ละโพสต์ โดยการใช้ route('posts.show', { id: post.id }) เพื่อสร้างลิงก์ที่สามารถคลิกไปยังหน้ารายละเอียดของโพสต์นั้นได้.

    สุดท้ายจะมีปุ่ม New ซึ่งเชื่อมโยงไปยังหน้าสร้างโพสต์ใหม่ (route('posts.create')) ที่ใช้งาน @!button เป็นส่วนหนึ่งของการใช้งานโครงสร้างปุ่มเพื่อให้ผู้ใช้สามารถคลิกเพื่อไปยังหน้าสร้างโพสต์ใหม่ได้อย่างง่ายดาย.`,
    code: `
      @layouts.master({title:"Posts"})
        <h1 class="ui header">Posts</h1>
        <ul class="ui bullet list">
          @each(post in posts)
            <li>
              <a href="{{ route('posts.show',{id: post.id}) }}">{{ post.title }}</a>
            </li>
          @endeach
        </ul>
        @!button({ label: 'New', action: route('posts.create') })
      @end`,
  },
  {
    id: 23,
    title: '',
    header: 'Detail',
    body: `
    ในส่วนนี้ของโค้ดจะเป็นการแสดงรายละเอียดของโพสต์ที่ผู้ใช้เลือก โดยการใช้ @layouts.master เพื่อเลือกใช้แม่แบบ (layout) สำหรับหน้าเว็บ ซึ่งหัวข้อของหน้านี้จะตั้งค่าให้ตรงกับชื่อของโพสต์ที่เลือกมา (post.title). หลังจากนั้นมีการใช้ @alert สำหรับแสดงหน้าต่างป๊อปอัพ (modal) ที่จะถามผู้ใช้ว่า "Do you want to delete {{ post.title }}?" ซึ่งในหน้าต่างนี้จะมีปุ่มให้ผู้ใช้เลือกว่าจะดำเนินการต่อไปหรือยกเลิก โดยการใช้ @slot เพื่อแบ่งแยกเนื้อหาหลักและปุ่มการกระทำออกจากกัน ในส่วนของเนื้อหาหลักจะมีข้อความถามว่า "Do you want to delete?" และในส่วนของปุ่มจะมีปุ่มสองปุ่ม คือ ปุ่ม "Delete" ที่จะให้ผู้ใช้ยืนยันการลบโพสต์ และปุ่ม "Cancel" ที่จะให้ผู้ใช้ยกเลิกการลบโพสต์

    ถัดมาคือการแสดงรายละเอียดของโพสต์เอง โดยใช้ {{ post.title }} เพื่อแสดงชื่อโพสต์ และ {{ post.body }} สำหรับแสดงเนื้อหาของโพสต์นั้นๆ หลังจากแสดงข้อมูลโพสต์แล้วจะมีปุ่มที่ผู้ใช้สามารถเลือกทำงานต่อได้ โดยปุ่มแรกจะเป็น "Back" เพื่อให้ผู้ใช้กลับไปยังหน้าหลักของโพสต์, ปุ่มที่สองคือ "Edit" ซึ่งจะพาผู้ใช้ไปยังหน้าแก้ไขโพสต์นั้น และปุ่มสุดท้ายคือ "Delete" ซึ่งเมื่อคลิกแล้วจะเปิดหน้าต่างป๊อปอัพยืนยันการลบโพสต์

    สุดท้ายในส่วนของ @slot('script') จะมีการใช้ JavaScript ร่วมกับ jQuery เพื่อเพิ่มฟังก์ชันให้กับปุ่ม "Delete" เมื่อคลิกที่ปุ่มนี้จะเปิดหน้าต่าง modal ยืนยันการลบ โดยเมื่อผู้ใช้คลิกปุ่ม "Approve" เพื่อยืนยันการลบ หน้าเว็บจะทำการเปลี่ยนเส้นทางไปยัง URL ที่ใช้ route('posts.delete', { id: post.id }) เพื่อให้ระบบทำการลบโพสต์ที่มี ID ที่ตรงกับโพสต์นั้นจากฐานข้อมูล.`,
    code: `
      @layouts.master({ title: post.title })
        @alert({ title: 'Delete?' })
            @slot('main')
                <p>Do you want to delete {{ post.title }}?</p>
            @end
            @slot('actions')
                <div class="ui green approve button">Delete</div>
                <div class="ui red deny button">Cancel</div>
            @end
        @end
        <h1 class="ui header">{{ post.title }}</h1>
        <p>{{ post.body }}</p>
        @!button({ label: 'Back', action: route('posts.home') })
        @!button({ label: 'Edit', action: route('posts.edit', { id: post.id }) })
        @!button({ label: 'Delete', action: 'javascript:void(0);', name: 'delete' })

        @slot('script')
            <script>
                $(document).ready(function() {
                    $('.ui.button.delete').click(function() {
                        $('.ui.modal').modal({
                            closable: false,
                            onApprove: function() {
                                window.location.href = "{{ route('posts.delete', { id: post.id }) }}";
                            }
                        }).modal('show');
                    });
                });
            </script>
        @end
      @end`,
  },
  {
    id: 24,
    title: '',
    header: 'Post',
    body: `
    โค้ดส่วนนี้จะเกี่ยวข้องกับการสร้างหรือแก้ไขโพสต์ในแอปพลิเคชัน โดยการใช้แม่แบบ (layout) ที่กำหนดชื่อหัวข้อเป็น "New Post" หรือ "Edit Post" ขึ้นอยู่กับว่าเป็นการสร้างโพสต์ใหม่หรือแก้ไขโพสต์ที่มีอยู่แล้ว ถ้าโพสต์มีอยู่แล้ว (มีค่าตัวแปร post) หัวข้อจะเป็น "Edit Post" ถ้าไม่มีก็จะแสดง "New Post" แทน

    ในฟอร์มการสร้างหรือแก้ไขโพสต์นี้ เราจะใช้แท็ก <form> โดยใช้ method POST ซึ่งส่งข้อมูลไปยังเส้นทางที่เหมาะสมสำหรับการบันทึกหรืออัปเดตโพสต์ ขึ้นอยู่กับว่ามี post หรือไม่ ถ้ามีโพสต์ที่จะแก้ไขจะใช้ route('posts.update', { id: post.id }) สำหรับการอัปเดต ถ้าไม่มีโพสต์จะใช้ route('posts.store') เพื่อเก็บโพสต์ใหม่. โค้ดนี้ยังใช้ฟังก์ชัน csrfField() เพื่อป้องกันการโจมตีด้วย CSRF.

    ในฟอร์มนี้จะมีการใช้ @!input และ @!textarea สำหรับแสดงฟอร์มการป้อนข้อมูล ซึ่งสำหรับช่อง "Title" จะมีค่าพื้นฐานเป็นชื่อโพสต์เก่าถ้ามีโพสต์ที่จะแก้ไข ถ้าไม่มีจะเป็นค่าว่าง โดยใช้ post ? post.title : '' และสำหรับเนื้อหาหรือ "Body" ก็จะใช้วิธีเดียวกัน.

    ส่วนของปุ่มจะประกอบด้วยปุ่ม "Save" สำหรับบันทึกข้อมูล และปุ่ม "Cancel" เพื่อยกเลิกและกลับไปยังหน้าหลักของโพสต์. ทั้งสองปุ่มจะถูกห่อหุ้มด้วย div ที่มีคลาส ui buttons เพื่อจัดรูปแบบให้ดูดี.`,
    code: `
      @layouts.master({title:"New Post"})
        <h1>{{ post ? 'Edit Post' : 'New Post' }} </h1>

        <form class="ui form" action="{{ post ? route('posts.update',{id: post.id}) : route('posts.store') }}" method="POST">
            {{ csrfField() }}
            @!input({ label: 'Title', name: 'title', value: post ? post.title : '', size: 50, type: 'text', placeholder: 'Please fill out this field.', })
            @!textarea({ label: 'Body', name: 'body', value: post ? post.body : '', placeholder: 'Please fill out this field.', rows: 5, cols: 50 })
            <div class="ui buttons">
                @!input({ name: 'submit', value: 'Save', type: 'submit' })
                <div style="margin-right: 10px;"></div>
                @!button({ label: 'Cancel', action: route('posts.home') })
            </div>
        </form>
      @end`,
  },
  {
    id: 25,
    title: '',
    header: 'โครงสร้าง',
    body: `
    โค้ดในส่วนนี้เป็นการสร้าง Controller ใน AdonisJS ซึ่งมีหน้าที่ในการจัดการข้อมูลโพสต์ (Posts). โดยเริ่มจากการนำเข้าคลาส HttpContext จาก AdonisJS เพื่อใช้ในการจัดการกับคำขอ HTTP ในแต่ละฟังก์ชันภายใน Controller.

    ในโค้ดนี้ เราจะเห็นว่าได้มีการกำหนดโครงสร้างของข้อมูลโพสต์โดยใช้ interface ในการประกาศประเภทข้อมูลที่ประกอบไปด้วยสามฟิลด์หลัก ได้แก่ id ซึ่งเป็นหมายเลขประจำตัวของโพสต์, title ที่เป็นชื่อเรื่องของโพสต์ และ body ที่เก็บเนื้อหาของโพสต์นั้นๆ.

    ข้อมูลของโพสต์ถูกเก็บในอาร์เรย์ posts ซึ่งประกอบด้วยข้อมูลโพสต์ตัวอย่างสองรายการ. แต่ละรายการในอาร์เรย์นี้จะประกอบด้วย id, title, และ body. ซึ่งจะใช้เพื่อทดสอบหรือจัดการข้อมูลโพสต์ในระบบ.

    หลังจากการกำหนดข้อมูลโพสต์แล้ว, PostsController จะทำหน้าที่เป็นตัวกลางในการจัดการข้อมูลเหล่านี้. โดยในตัวอย่างนี้, ยังไม่ได้มีการเพิ่มฟังก์ชันที่จะทำงานกับข้อมูลโพสต์เข้ามาในคลาสนี้. อย่างไรก็ตาม, โค้ดที่มีอยู่นี้เป็นการตั้งโครงสร้างพื้นฐานสำหรับการจัดการโพสต์ที่สามารถขยายได้ในภายหลัง, เช่น การแสดงโพสต์ทั้งหมด การสร้างโพสต์ใหม่ การแก้ไขโพสต์ที่มีอยู่ หรือการลบโพสต์จากระบบ.

    สรุปแล้ว โค้ดนี้เป็นการตั้งต้นสำหรับการจัดการข้อมูลโพสต์ใน AdonisJS โดยมีการกำหนดโครงสร้างข้อมูลโพสต์และเตรียมคลาส PostsController ไว้สำหรับการขยายฟังก์ชันการทำงานต่างๆ ที่เกี่ยวข้องกับโพสต์ในระบบ.`,
    code: `
      import type { HttpContext } from '@adonisjs/core/http'

      interface Post {
          id: number
          title: string
          body: string
      }

      const posts: Post[] = [
          {
              id: 1,
              title: 'Hello AdonisJS',
              body: 'Adonis includes everything you need to create fully functional web app or an API server.'
          },
          {
              id: 2,
              title: 'VueJS',
              body: 'Vue is a progressive framework for building user interfaces.'
          }
      ]

      export default class PostsController {
          ... นำฟังก์ชันมาใส่ข้างในนี้
      }`,
  },
  {
    id: 26,
    title: '',
    header: 'Index',
    body: `
    โค้ดส่วนนี้เป็นฟังก์ชัน index ที่อยู่ใน PostsController ซึ่งจะถูกใช้เพื่อแสดงรายการโพสต์ทั้งหมดในแอปพลิเคชัน. ฟังก์ชันนี้รับพารามิเตอร์ view จาก HttpContext ซึ่งช่วยในการเรนเดอร์มุมมอง (view) ที่ต้องการแสดงผลให้ผู้ใช้.

    ภายในฟังก์ชันนี้, view.render('posts', { posts: posts }) ถูกใช้ในการเรนเดอร์มุมมองชื่อ posts. พารามิเตอร์ { posts: posts } เป็นการส่งข้อมูลโพสต์ทั้งหมดที่อยู่ในตัวแปร posts ไปยังมุมมองนี้, เพื่อให้สามารถแสดงโพสต์เหล่านั้นในหน้าผู้ใช้ได้.

    ในกรณีนี้, ข้อมูลโพสต์ (ที่ถูกเก็บไว้ในตัวแปร posts) จะถูกส่งไปยังมุมมอง posts ซึ่งทำให้ในหน้าเว็บแสดงผลโพสต์ทั้งหมดที่มีในระบบ, หรือแสดงข้อมูลที่เก็บอยู่ในตัวแปร posts.

    โดยสรุป, ฟังก์ชัน index นี้ทำหน้าที่ในการดึงข้อมูลโพสต์ทั้งหมดและส่งข้อมูลนี้ไปแสดงในหน้า posts.`,
    code: `
      async index({ view }: HttpContext) {
        return view.render('posts', { posts: posts })
      }`,
  },
  {
    id: 27,
    title: '',
    header: 'Show',
    body: `
    โค้ดในฟังก์ชัน show นี้มีหน้าที่ในการแสดงรายละเอียดของโพสต์ที่เลือก โดยใช้ ID ที่ได้รับจากพารามิเตอร์ใน URL.

    เริ่มจากการรับพารามิเตอร์ params ซึ่งมาจาก HTTP request ที่ผู้ใช้ส่งมา, ฟังก์ชันนี้จะดึงค่า id จาก params.id ซึ่งเป็น ID ของโพสต์ที่ต้องการดูรายละเอียด. จากนั้น, posts.find((p) => p.id == Number(id)) จะทำการค้นหาผ่านข้อมูลทั้งหมดในตัวแปร posts เพื่อหาผู้โพสต์ที่มี id ตรงกับค่า id ที่ได้รับจาก URL. หากพบโพสต์ที่ตรงกัน, โพสต์นั้นจะถูกเก็บในตัวแปร post.

    เมื่อโพสต์ที่ต้องการถูกค้นพบแล้ว, ฟังก์ชัน view.render('detail', { post: post }) จะทำการเรนเดอร์มุมมองชื่อ detail พร้อมกับส่งข้อมูลของโพสต์ที่พบไปยังมุมมองนั้น. ข้อมูลโพสต์จะถูกส่งในรูปแบบของอ็อบเจ็กต์ post ซึ่งจะสามารถนำไปใช้ในการแสดงผลรายละเอียดโพสต์ในหน้าเว็บได้.

    สรุปคือ ฟังก์ชัน show นี้ทำหน้าที่ในการค้นหาโพสต์ที่ตรงกับ id ที่ได้รับจาก URL และแสดงรายละเอียดโพสต์นั้นในมุมมอง detail.`,
    code: `
      async show({ params, view }: HttpContext) {
        const id = params.id
        const post = posts.find((p) => p.id == Number(id))

        return view.render('detail', { post: post })
      }`,
  },
  {
    id: 28,
    title: '',
    header: 'Create',
    body: `
    ฟังก์ชัน create ในโค้ดนี้มีหน้าที่ในการเตรียมการแสดงฟอร์มเพื่อสร้างโพสต์ใหม่. เมื่อฟังก์ชันนี้ถูกเรียก, มันจะทำการเรนเดอร์มุมมอง (view) ที่ชื่อว่า post.

    มุมมอง post นี้จะถูกแสดงให้ผู้ใช้เห็นในลักษณะของฟอร์มที่สามารถกรอกข้อมูลโพสต์ใหม่ เช่น ชื่อเรื่องและเนื้อหา. ฟังก์ชันนี้ไม่มีการส่งข้อมูลเพิ่มเติมไปยังมุมมอง, ดังนั้นมันจะเพียงแค่แสดงฟอร์มเปล่าๆ ให้ผู้ใช้กรอกข้อมูลตามต้องการ.

    สรุปคือ ฟังก์ชัน create ทำหน้าที่ในการแสดงฟอร์มสร้างโพสต์ใหม่ให้กับผู้ใช้.`,
    code: `
      async create({ view }: HttpContext) {
        return view.render('post')
      }`,
  },
  {
    id: 29,
    title: '',
    header: 'Store',
    body: `
    ฟังก์ชัน store ในโค้ดนี้ทำหน้าที่ในการบันทึกโพสต์ใหม่ที่ผู้ใช้กรอกผ่านฟอร์ม เมื่อผู้ใช้ส่งข้อมูลมา, ฟังก์ชันจะเริ่มต้นโดยการดึงข้อมูลจากฟอร์มที่ผู้ใช้กรอกไว้ เช่น ชื่อเรื่อง (title) และเนื้อหา (body) ผ่านคำสั่ง request.input() ซึ่งจะทำให้เราได้ข้อมูลที่ต้องการ. จากนั้น, ฟังก์ชันจะสร้าง id ใหม่ให้กับโพสต์ โดยการใช้ความยาวของอาร์เรย์ posts บวก 1 เพื่อให้ได้ ID ที่ไม่ซ้ำกันกับโพสต์อื่น ๆ ในระบบ.

    หลังจากนั้น, โค้ดจะสร้างอ็อบเจ็กต์ newPost ที่มีโครงสร้างตาม Post interface โดยประกอบไปด้วย id, title, และ body ที่ได้รับจากผู้ใช้. อ็อบเจ็กต์นี้จะถูกเพิ่มเข้าไปในอาร์เรย์ posts, ซึ่งเป็นที่เก็บข้อมูลทั้งหมดของโพสต์ในระบบ. เมื่อข้อมูลถูกบันทึกเรียบร้อยแล้ว, ฟังก์ชันจะใช้ response.redirect() เพื่อนำผู้ใช้ไปยังหน้าหลักของโพสต์, ซึ่งจะเป็นการแสดงโพสต์ทั้งหมดที่มีในระบบ.

    ฟังก์ชันนี้จึงทำหน้าที่ในการรับข้อมูลจากผู้ใช้, สร้างโพสต์ใหม่, บันทึกโพสต์ลงในอาร์เรย์, และเปลี่ยนเส้นทางผู้ใช้ไปยังหน้าหลักของโพสต์.`,
    code: `
      async store({ request, response }: HttpContext) {
        const title = request.input('title')
        const body = request.input('body')
        const newId = posts.length + 1
        const newPost: Post = { id: newId, title: title, body: body }

        posts.push(newPost)

        response.redirect().toRoute('posts.home')
      }`,
  },
  {
    id: 30,
    title: '',
    header: 'Edit',
    body: `
    ฟังก์ชัน edit ในโค้ดนี้ทำหน้าที่ในการแสดงหน้าให้ผู้ใช้สามารถแก้ไขโพสต์ที่มีอยู่แล้วในระบบ โดยฟังก์ชันนี้จะเริ่มต้นด้วยการดึง id ของโพสต์ที่ต้องการแก้ไขจาก URL ผ่าน params.id. จากนั้น, โค้ดจะใช้ find() เพื่อค้นหาโพสต์ในอาร์เรย์ posts โดยใช้ id ที่ได้จาก URL ซึ่งจะทำให้ได้โพสต์ที่ตรงกับ id ที่ผู้ใช้ต้องการแก้ไข.

    เมื่อโพสต์ที่ตรงกับ id ถูกค้นพบแล้ว, ฟังก์ชันจะส่งข้อมูลของโพสต์นั้นไปยังหน้าฟอร์มแก้ไขผ่านคำสั่ง view.render(). โดยข้อมูลที่ถูกส่งไปยังหน้าฟอร์มจะถูกเก็บในตัวแปร post ซึ่งสามารถนำไปแสดงในฟอร์ม เพื่อให้ผู้ใช้สามารถแก้ไขข้อมูลต่าง ๆ เช่น ชื่อเรื่องและเนื้อหาของโพสต์ได้.

    ฟังก์ชันนี้จึงทำหน้าที่ในการค้นหาโพสต์ที่ต้องการแก้ไขจากฐานข้อมูล (ในที่นี้คืออาร์เรย์ posts), และนำข้อมูลของโพสต์นั้นไปแสดงในฟอร์มให้ผู้ใช้สามารถแก้ไขได้.`,
    code: `
      async edit({ params, view }: HttpContext) {
        const id = params.id
        const post = posts.find((p) => p.id == Number(id))

        return view.render('post', { post: post })
      }`,
  },
  {
    id: 31,
    title: '',
    header: 'Update',
    body: `
    ฟังก์ชัน update ในโค้ดนี้ทำหน้าที่ในการอัพเดตโพสต์ที่มีอยู่แล้วในระบบ โดยฟังก์ชันนี้เริ่มต้นด้วยการดึง id ของโพสต์ที่ต้องการอัพเดตจาก URL ผ่าน params.id. จากนั้น, โค้ดจะใช้ findIndex() เพื่อตรวจสอบหาตำแหน่งของโพสต์ในอาร์เรย์ posts ที่มี id ตรงกับ id ที่ผู้ใช้ต้องการแก้ไข.

    เมื่อค้นหาตำแหน่งของโพสต์ในอาร์เรย์เจอ, โค้ดจะทำการอัพเดตค่าของ title และ body ของโพสต์นั้น โดยรับข้อมูลใหม่ที่ผู้ใช้กรอกในฟอร์มจาก request.input(). ข้อมูลใหม่นี้จะถูกนำไปแทนที่ข้อมูลเดิมในโพสต์ที่มี id ตรงกับที่ค้นพบ.

    สุดท้าย, เมื่อการอัพเดตเสร็จสมบูรณ์, ฟังก์ชันจะทำการเปลี่ยนเส้นทางผู้ใช้กลับไปที่หน้า posts.home โดยใช้ response.redirect().toRoute() เพื่อแสดงผลลัพธ์ของการอัพเดตโพสต์ที่สำเร็จ.`,
    code: `
      async update({ params, request, response }: HttpContext) {
        const id = params.id
        const index = posts.findIndex((p) => p.id == Number(id))

        posts[index].title = request.input('title')
        posts[index].body = request.input('body')
        response.redirect().toRoute('posts.home')
      }`,
  },
  {
    id: 32,
    title: '',
    header: 'Destroy',
    body: `
    ฟังก์ชัน destroy ในโค้ดนี้มีหน้าที่ในการลบโพสต์ที่มี id ตรงกับค่าที่ได้รับจาก params.id ซึ่งมาจาก URL. เริ่มต้นด้วยการดึง id ของโพสต์ที่ต้องการลบจาก params.id, จากนั้นใช้ findIndex() เพื่อตรวจสอบหาตำแหน่งของโพสต์ในอาร์เรย์ posts ที่มี id ตรงกัน.

    เมื่อพบตำแหน่งของโพสต์ที่ต้องการลบ, ฟังก์ชันจะใช้ splice() เพื่อลบโพสต์นั้นออกจากอาร์เรย์ posts. splice(index, 1) จะลบโพสต์ที่ตำแหน่ง index ซึ่งเป็นตำแหน่งที่โพสต์นั้นอยู่.

    หลังจากทำการลบโพสต์เสร็จสิ้น, ฟังก์ชันจะทำการเปลี่ยนเส้นทางผู้ใช้กลับไปยังหน้า posts.home โดยใช้ response.redirect().toRoute() เพื่อให้ผู้ใช้เห็นผลการลบโพสต์ที่สำเร็จ.`,
    code: `
      async destroy({ params, response }: HttpContext) {
        const id = params.id
        const index = posts.findIndex((p) => p.id == Number(id))
        posts.splice(index, 1)

        response.redirect().toRoute('posts.home')
      }`,
  },
]
